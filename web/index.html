<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ball Balance Tuner</title>
    <style>
      html,body{height:100%;overflow:hidden}
      body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0e0f12;color:#eee;margin:0}
      header{padding:12px 16px;background:#151821;border-bottom:1px solid #282c34;height:60px;box-sizing:border-box}
      .wrap{display:flex;gap:16px;padding:16px;height:calc(100vh - 60px);box-sizing:border-box;overflow:hidden}
      .card{background:#14161b;border:1px solid #2a2f3a;border-radius:8px;padding:12px;box-sizing:border-box;overflow:hidden}
      .left{flex:2;min-width:0;display:grid;grid-template-rows:minmax(0,1fr) minmax(0,1fr) 18px;row-gap:12px}
      .right{flex:1;min-width:320px;display:flex;flex-direction:column;overflow:auto}
      label{display:block;margin:6px 0 2px;color:#9fb1c9}
      input[type="number"],select{width:100%;padding:8px;border-radius:6px;border:1px solid #2c3340;background:#0e1117;color:#e6edf3}
      button{padding:8px 10px;border-radius:6px;border:1px solid #324055;background:#1a2233;color:#e6edf3;cursor:pointer}
      button:hover{background:#1f2940}
      .row{display:flex;gap:8px}
      .chartWrap{position:relative;width:100%;height:100%;min-height:0}
      .chartWrap.secondary{height:100%}
      canvas{background:#0b0d12;border:1px solid #2a2f3a;border-radius:6px;width:100%!important;height:100%!important}
      .muted{color:#9fb1c9;font-size:12px}
      .status{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
      .trajWrap{flex:1 1 auto;display:flex;flex-direction:column;gap:8px;margin-top:8px;overflow:hidden;align-items:center;justify-content:center;min-height:0}
      #trajBox{width:100%;max-height:100%;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center}
      #traj{display:block;background:#0b0d12;border:1px solid #2a2f3a;border-radius:6px;width:100%;height:100%}
      /* Maintain overall layout in viewport: charts equal height; right can scroll */
    </style>
  </head>
  <body>
    <header>
      <h3 style="margin:0">Ball Balance Tuner</h3>
      <div class="muted">Live setpoint vs response and on-the-fly parameter tuning</div>
    </header>
    <div class="wrap">
      <div class="left card" style="display:grid;grid-template-rows:minmax(0,1fr) minmax(0,1fr) 18px;row-gap:12px">
        <div class="chartWrap">
          <canvas id="chart"></canvas>
        </div>
        <div class="chartWrap secondary">
          <canvas id="angleChart"></canvas>
        </div>
        <div class="muted status" id="status"></div>
      </div>
      <div class="right card">
        <div class="row">
          <div style="flex:1">
            <label>Control Method</label>
            <select id="method">
              <option value="pid">PID</option>
              <option value="lqr">LQR</option>
              <option value="rl">RL</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Circle</label>
            <select id="circle_on">
              <option value="off">Off</option>
              <option value="on">On</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Setpoint X (m)</label>
            <input id="spx" type="number" step="0.005" value="0" />
          </div>
          <div style="flex:1">
            <label>Setpoint Y (m)</label>
            <input id="spy" type="number" step="0.005" value="0" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Circle Radius (m)</label>
            <input id="radius" type="number" step="0.005" value="0.05" />
          </div>
          <div style="flex:1">
            <label>Circle Speed</label>
            <input id="speed" type="number" step="0.1" value="1.0" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Invert Circle</label>
            <select id="invert">
              <option value="false">No</option>
              <option value="true">Yes</option>
            </select>
          </div>
          <div style="flex:1">
            <label>IMU Nudge Gain</label>
            <input id="imu_gain" type="number" step="0.01" min="0" max="1" value="0.08" />
          </div>
        </div>
        <hr style="border-color:#2a2f3a" />
        <div class="row">
          <div style="flex:1">
            <label>Pitch Kp</label>
            <input id="pp_kp" type="number" step="0.01" />
          </div>
          <div style="flex:1">
            <label>Pitch Ki</label>
            <input id="pp_ki" type="number" step="0.001" />
          </div>
          <div style="flex:1">
            <label>Pitch Kd</label>
            <input id="pp_kd" type="number" step="0.01" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Roll Kp</label>
            <input id="pr_kp" type="number" step="0.01" />
          </div>
          <div style="flex:1">
            <label>Roll Ki</label>
            <input id="pr_ki" type="number" step="0.001" />
          </div>
          <div style="flex:1">
            <label>Roll Kd</label>
            <input id="pr_kd" type="number" step="0.01" />
          </div>
        </div>
        <div style="margin-top:8px" class="row">
          <button id="apply_pid">Apply PID</button>
          <button id="apply_sp">Apply Setpoint</button>
          <button id="apply_circle">Apply Circle</button>
        </div>
        <div class="trajWrap">
          <div id="trajBox">
            <canvas id="traj"></canvas>
          </div>
        </div>
        <hr style="border-color:#2a2f3a" />
        </div>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
      const ws = new WebSocket(wsUrl);

      const chartEl = document.getElementById('chart');
      const angleChartEl = document.getElementById('angleChart');
      const trajEl = document.getElementById('traj');
      const statusEl = document.getElementById('status');
      const methodSel = document.getElementById('method');
      const spxEl = document.getElementById('spx');
      const spyEl = document.getElementById('spy');
      const circleOn = document.getElementById('circle_on');
      const radiusEl = document.getElementById('radius');
      const speedEl = document.getElementById('speed');
      const invertEl = document.getElementById('invert');
      const pp_kp = document.getElementById('pp_kp');
      const pp_ki = document.getElementById('pp_ki');
      const pp_kd = document.getElementById('pp_kd');
      const pr_kp = document.getElementById('pr_kp');
      const pr_ki = document.getElementById('pr_ki');
      const pr_kd = document.getElementById('pr_kd');
      const imuGainEl = document.getElementById('imu_gain');
      const tolEl = document.getElementById('tol');
      const dwellEl = document.getElementById('dwell');

      const WINDOW_SEC = 12; // moving window length
      const dataX = { sp: [], y: [] };
      const dataY = { sp: [], y: [] };
      const traj = { sp: [], xy: [] };

      const chart = new Chart(chartEl, {
        type: 'line',
        data: {
          datasets: [
            { label: 'X setpoint', data: dataX.sp, borderColor: '#f2cc60', borderWidth: 3, pointRadius: 0 },
            { label: 'X actual',   data: dataX.y,  borderColor: '#58a6ff', borderWidth: 3, pointRadius: 0 },
            { label: 'Y setpoint', data: dataY.sp, borderColor: '#ff7b72', borderWidth: 3, pointRadius: 0 },
            { label: 'Y actual',   data: dataY.y,  borderColor: '#a371f7', borderWidth: 3, pointRadius: 0 }
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          spanGaps: true,
          scales: {
            x: { type: 'linear', display: true, min: 0, max: WINDOW_SEC, title: { text: 'Time (s)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
            y: { display: true, title: { text: 'Position (m)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } }
          },
          plugins: { legend: { labels: { color: '#c9d1d9' } } }
        }
      });

      // Commanded vs Actual angles (deg)
      const angData = { cp: [], cr: [], ap: [], ar: [] };
      const angleChart = new Chart(angleChartEl, {
        type: 'line',
        data: {
          datasets: [
            { label: 'Cmd Pitch (deg)', data: angData.cp, borderColor: '#58a6ff', borderWidth: 3, pointRadius: 0 },
            { label: 'Act Pitch (deg)', data: angData.ap, borderColor: '#1f6feb', borderWidth: 3, pointRadius: 0 },
            { label: 'Cmd Roll (deg)',  data: angData.cr, borderColor: '#ff7b72', borderWidth: 3, pointRadius: 0 },
            { label: 'Act Roll (deg)',  data: angData.ar, borderColor: '#bd561d', borderWidth: 3, pointRadius: 0 },
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          spanGaps: true,
          scales: {
            x: { type: 'linear', display: true, min: 0, max: WINDOW_SEC, title: { text: 'Time (s)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
            y: { position: 'left', title: { text: 'Angle (deg)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
          },
          plugins: { legend: { labels: { color: '#c9d1d9' } } }
        }
      });

      function addPoint(t, spx, x, spy, y) {
        dataX.sp.push({ x: t, y: spx });
        dataX.y.push({ x: t, y: x });
        dataY.sp.push({ x: t, y: spy });
        dataY.y.push({ x: t, y: y });
        traj.sp.push({ x: spx, y: spy });
        traj.xy.push({ x, y });
      }

      function addAnglePoints(t, cpDeg, apDeg, crDeg, arDeg) {
        angData.cp.push({ x: t, y: cpDeg });
        angData.ap.push({ x: t, y: apDeg });
        angData.cr.push({ x: t, y: crDeg });
        angData.ar.push({ x: t, y: arDeg });
      }

      let t0 = null;
      let lastDraw = 0;
      let samples = 0;
      let lastRateT = 0;
      let measuredRate = 0;
      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'state') {
          const s = msg.data || {};
          methodSel.value = s.control_method || 'pid';
          spxEl.value = s.setpoint_x ?? 0;
          spyEl.value = s.setpoint_y ?? 0;
          if (typeof s.imu_feedback_gain === 'number') imuGainEl.value = s.imu_feedback_gain;
          if (s.pid) {
            pp_kp.value = s.pid.pitch.kp; pp_ki.value = s.pid.pitch.ki; pp_kd.value = s.pid.pitch.kd;
            pr_kp.value = s.pid.roll.kp; pr_ki.value = s.pid.roll.ki; pr_kd.value = s.pid.roll.kd;
          }
        } else if (msg.type === 'telemetry') {
          const d = msg.data || {};
          if (t0 == null) t0 = d.t;
          const t = d.t - t0;
          addPoint(t, d.setpoint_x, d.ball_x, d.setpoint_y, d.ball_y);
          samples++;
          if (!lastRateT) lastRateT = d.t; else if (d.t - lastRateT >= 1.0) { measuredRate = samples / (d.t - lastRateT); samples = 0; lastRateT = d.t; }

          // Commanded vs actual angles (deg): prefer IMU when connected
          const cmdPitchDeg = ((d.action?.[0] ?? 0) * 180 / Math.PI);
          const cmdRollDeg  = ((d.action?.[1] ?? 0) * 180 / Math.PI);
          const imuConnected = !!(d.imu && d.imu.connected);
          const actPitchDeg = imuConnected ? (d.imu.pitch ?? 0) : ((d.pitch ?? 0) * 180 / Math.PI);
          const actRollDeg  = imuConnected ? (d.imu.roll ?? 0)  : ((d.roll  ?? 0) * 180 / Math.PI);
          addAnglePoints(t, cmdPitchDeg, actPitchDeg, cmdRollDeg, actRollDeg);

          statusEl.textContent = `render ~${(1000/Math.max(1, performance.now()-lastDraw)).toFixed(0)} fps | recv ${measuredRate.toFixed(0)} Hz`;
        }
      };

      // Smooth render loop decoupled from WS rate (~30 fps)
      function renderLoop(ts) {
        if (!lastDraw || ts - lastDraw > 33) { // ~30Hz
          const all = [dataX.sp, dataX.y, dataY.sp, dataY.y];
          // Trim to moving window
          let tMax = 0;
          for (const arr of all) if (arr.length) tMax = Math.max(tMax, arr[arr.length - 1].x);
          const tMin = Math.max(0, tMax - WINDOW_SEC);
          for (const arr of all) {
            while (arr.length && arr[0].x < tMin) arr.shift();
          }
          chart.options.scales.x.min = tMin;
          chart.options.scales.x.max = tMin + WINDOW_SEC;
          chart.update('none');
          // Trim second chart
          const all2 = [angData.cp, angData.ap, angData.cr, angData.ar];
          let tMax2 = 0;
          for (const arr of all2) if (arr.length) tMax2 = Math.max(tMax2, arr[arr.length - 1].x);
          const tMin2 = Math.max(0, tMax2 - WINDOW_SEC);
          for (const arr of all2) {
            while (arr.length && arr[0].x < tMin2) arr.shift();
          }
          angleChart.options.scales.x.min = tMin2;
          angleChart.options.scales.x.max = tMin2 + WINDOW_SEC;
          angleChart.update('none');

          // Draw trajectory square (keep same number of points as time graphs)
          const ctx = trajEl.getContext('2d');
          // Use CSS-sized square box; match canvas to its CSS size to avoid growth
          const box = document.getElementById('trajBox');
          // Lock the square size to the box width to avoid vertical-driven resizing
          const side = Math.floor(box.clientWidth);
          if (side <= 0) return;
          trajEl.width = side;
          trajEl.height = side;
          const w = side, h = side;
          ctx.clearRect(0,0,w,h);
          // 25cm table -> ±0.125m, 2cm corner radius
          const half = 0.125;
          const full = 2 * half;
          const radiusM = 0.02;
          // Pixels-per-meter scale derived from side minus padding
          const s = (w) / full;
          const toXY = (p) => ({
            x: Math.round((p.x + half) * s + rectX),
            y: Math.round((half - p.y) * s + rectY)
          });
          // Rounded table border
          const drawRoundedRect = (x, y, rw, rh, r) => {
            const rr = Math.max(1, Math.min(r, Math.min(rw, rh) / 2));
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.lineTo(x + rw - rr, y);
            ctx.quadraticCurveTo(x + rw, y, x + rw, y + rr);
            ctx.lineTo(x + rw, y + rh - rr);
            ctx.quadraticCurveTo(x + rw, y + rh, x + rw - rr, y + rh);
            ctx.lineTo(x + rr, y + rh);
            ctx.quadraticCurveTo(x, y + rh, x, y + rh - rr);
            ctx.lineTo(x, y + rr);
            ctx.quadraticCurveTo(x, y, x + rr, y);
            ctx.closePath();
          };
          ctx.strokeStyle = '#e6edf3';
          ctx.lineWidth = 2;
          const rectX = Math.round((w - full * s) / 2);
          const rectY = Math.round((h - full * s) / 2);
          const rectW = Math.round(full * s);
          const rectH = Math.round(full * s);
          // Drawing complete
          drawRoundedRect(rectX, rectY, rectW, rectH, radiusM * s);
          ctx.stroke();
          // Trim trajectories to visible window length
          const maxLen = Math.min(dataX.sp.length, WINDOW_SEC*1000); // safe upper bound
          while (traj.sp.length > maxLen) traj.sp.shift();
          while (traj.xy.length > maxLen) traj.xy.shift();
          // Draw setpoint path
          if (traj.sp.length > 1) {
            ctx.strokeStyle = '#f2cc60';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const p0 = toXY(traj.sp[0]); ctx.moveTo(p0.x, p0.y);
            for (let i=1;i<traj.sp.length;i++){ const p = toXY(traj.sp[i]); ctx.lineTo(p.x,p.y); }
            ctx.stroke();
          }
          // Draw actual path
          if (traj.xy.length > 1) {
            ctx.strokeStyle = '#58a6ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const p0 = toXY(traj.xy[0]); ctx.moveTo(p0.x, p0.y);
            for (let i=1;i<traj.xy.length;i++){ const p = toXY(traj.xy[i]); ctx.lineTo(p.x,p.y); }
            ctx.stroke();
          }
          // Draw current ball as white circle (true scale ~1.5cm diameter)
          if (traj.xy.length > 0) {
            const last = traj.xy[traj.xy.length - 1];
            const bp = toXY(last);
            const ballRadiusPx = Math.max(3, (0.015 * 0.5) * s);
            ctx.beginPath();
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#c9d1d9';
            ctx.lineWidth = 1.5;
            ctx.arc(bp.x, bp.y, ballRadiusPx, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
          }
          lastDraw = ts;
        }
        requestAnimationFrame(renderLoop);
      }
      requestAnimationFrame(renderLoop);

      document.getElementById('apply_pid').onclick = () => {
        ws.send(JSON.stringify({ type: 'update_pid', data: { axis: 'pitch', kp: +pp_kp.value, ki: +pp_ki.value, kd: +pp_kd.value } }));
        ws.send(JSON.stringify({ type: 'update_pid', data: { axis: 'roll',  kp: +pr_kp.value, ki: +pr_ki.value, kd: +pr_kd.value } }));
      };
      document.getElementById('apply_sp').onclick = () => {
        ws.send(JSON.stringify({ type: 'set_setpoint', data: { x: +spxEl.value, y: +spyEl.value } }));
      };
      document.getElementById('apply_circle').onclick = () => {
        ws.send(JSON.stringify({ type: 'circle', data: { on: circleOn.value === 'on', radius: +radiusEl.value, speed: +speedEl.value, invert: invertEl.value === 'true' } }));
      };
      methodSel.onchange = () => {
        ws.send(JSON.stringify({ type: 'set_method', data: { method: methodSel.value } }));
      };
      imuGainEl.onchange = () => {
        const val = Math.max(0, Math.min(1, +imuGainEl.value || 0));
        imuGainEl.value = val;
        ws.send(JSON.stringify({ type: 'set_imu_gain', data: { gain: val } }));
      };

      // Click-to-set removed per request
    </script>
  </body>
  </html>

