<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ball Balance Tuner</title>
    <style>
      body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0e0f12;color:#eee;margin:0}
      header{padding:12px 16px;background:#151821;border-bottom:1px solid #282c34}
      .wrap{display:flex;gap:16px;padding:16px}
      .card{background:#14161b;border:1px solid #2a2f3a;border-radius:8px;padding:12px}
      .left{flex:2;min-width:0}
      .right{flex:1;min-width:320px}
      label{display:block;margin:6px 0 2px;color:#9fb1c9}
      input[type="number"],select{width:100%;padding:8px;border-radius:6px;border:1px solid #2c3340;background:#0e1117;color:#e6edf3}
      button{padding:8px 10px;border-radius:6px;border:1px solid #324055;background:#1a2233;color:#e6edf3;cursor:pointer}
      button:hover{background:#1f2940}
      .row{display:flex;gap:8px}
      .chartWrap{position:relative;width:100%;height:50vh}
      canvas{background:#0b0d12;border:1px solid #2a2f3a;border-radius:6px;width:100%!important;height:100%!important}
      .muted{color:#9fb1c9;font-size:12px}
    </style>
  </head>
  <body>
    <header>
      <h3 style="margin:0">Ball Balance Tuner</h3>
      <div class="muted">Live setpoint vs response and on-the-fly parameter tuning</div>
    </header>
    <div class="wrap">
      <div class="left card">
        <div class="chartWrap">
          <canvas id="chart"></canvas>
        </div>
        <div class="chartWrap" style="height:40vh;margin-top:12px">
          <canvas id="angleChart"></canvas>
        </div>
        <div class="muted" id="status" style="margin-top:8px"></div>
      </div>
      <div class="right card">
        <div class="row">
          <div style="flex:1">
            <label>Control Method</label>
            <select id="method">
              <option value="pid">PID</option>
              <option value="lqr">LQR</option>
              <option value="rl">RL</option>
            </select>
          </div>
          <div style="width:120px">
            <label>Circle</label>
            <select id="circle_on">
              <option value="off">Off</option>
              <option value="on">On</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Setpoint X (m)</label>
            <input id="spx" type="number" step="0.005" value="0" />
          </div>
          <div style="flex:1">
            <label>Setpoint Y (m)</label>
            <input id="spy" type="number" step="0.005" value="0" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Circle Radius (m)</label>
            <input id="radius" type="number" step="0.005" value="0.05" />
          </div>
          <div style="flex:1">
            <label>Circle Speed</label>
            <input id="speed" type="number" step="0.1" value="1.0" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Invert Circle</label>
            <select id="invert">
              <option value="false">No</option>
              <option value="true">Yes</option>
            </select>
          </div>
          <div style="flex:1">
            <label>IMU Nudge Gain</label>
            <input id="imu_gain" type="number" step="0.01" min="0" max="1" value="0.08" />
          </div>
        </div>
        <hr style="border-color:#2a2f3a" />
        <div class="row">
          <div style="flex:1">
            <label>Pitch Kp</label>
            <input id="pp_kp" type="number" step="0.01" />
          </div>
          <div style="flex:1">
            <label>Pitch Ki</label>
            <input id="pp_ki" type="number" step="0.001" />
          </div>
          <div style="flex:1">
            <label>Pitch Kd</label>
            <input id="pp_kd" type="number" step="0.01" />
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Roll Kp</label>
            <input id="pr_kp" type="number" step="0.01" />
          </div>
          <div style="flex:1">
            <label>Roll Ki</label>
            <input id="pr_ki" type="number" step="0.001" />
          </div>
          <div style="flex:1">
            <label>Roll Kd</label>
            <input id="pr_kd" type="number" step="0.01" />
          </div>
        </div>
        <div style="margin-top:8px" class="row">
          <button id="apply_pid">Apply PID</button>
          <button id="apply_sp">Apply Setpoint</button>
          <button id="apply_circle">Apply Circle</button>
        </div>
        <hr style="border-color:#2a2f3a" />
        <div class="row">
          <div style="flex:1">
            <label>Settle Tolerance (m)</label>
            <input id="tol" type="number" step="0.001" value="0.01" />
          </div>
          <div style="flex:1">
            <label>Settle Dwell (s)</label>
            <input id="dwell" type="number" step="0.1" value="0.5" />
          </div>
        </div>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
      const ws = new WebSocket(wsUrl);

      const chartEl = document.getElementById('chart');
      const angleChartEl = document.getElementById('angleChart');
      const statusEl = document.getElementById('status');
      const methodSel = document.getElementById('method');
      const spxEl = document.getElementById('spx');
      const spyEl = document.getElementById('spy');
      const circleOn = document.getElementById('circle_on');
      const radiusEl = document.getElementById('radius');
      const speedEl = document.getElementById('speed');
      const invertEl = document.getElementById('invert');
      const pp_kp = document.getElementById('pp_kp');
      const pp_ki = document.getElementById('pp_ki');
      const pp_kd = document.getElementById('pp_kd');
      const pr_kp = document.getElementById('pr_kp');
      const pr_ki = document.getElementById('pr_ki');
      const pr_kd = document.getElementById('pr_kd');
      const imuGainEl = document.getElementById('imu_gain');
      const tolEl = document.getElementById('tol');
      const dwellEl = document.getElementById('dwell');

      const WINDOW_SEC = 12; // moving window length
      const dataX = { sp: [], y: [] };
      const dataY = { sp: [], y: [] };

      const chart = new Chart(chartEl, {
        type: 'line',
        data: {
          datasets: [
            { label: 'X setpoint', data: dataX.sp, borderColor: '#f2cc60', borderWidth: 3, pointRadius: 0 },
            { label: 'X actual',   data: dataX.y,  borderColor: '#58a6ff', borderWidth: 3, pointRadius: 0 },
            { label: 'Y setpoint', data: dataY.sp, borderColor: '#ff7b72', borderWidth: 3, pointRadius: 0 },
            { label: 'Y actual',   data: dataY.y,  borderColor: '#a371f7', borderWidth: 3, pointRadius: 0 }
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          spanGaps: true,
          scales: {
            x: { type: 'linear', display: true, min: 0, max: WINDOW_SEC, title: { text: 'Time (s)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
            y: { display: true, title: { text: 'Position (m)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } }
          },
          plugins: { legend: { labels: { color: '#c9d1d9' } } }
        }
      });

      // Commanded vs Actual angles (deg)
      const angData = { cp: [], cr: [], ap: [], ar: [] };
      const angleChart = new Chart(angleChartEl, {
        type: 'line',
        data: {
          datasets: [
            { label: 'Cmd Pitch (deg)', data: angData.cp, borderColor: '#58a6ff', borderWidth: 3, pointRadius: 0 },
            { label: 'Act Pitch (deg)', data: angData.ap, borderColor: '#1f6feb', borderWidth: 3, pointRadius: 0 },
            { label: 'Cmd Roll (deg)',  data: angData.cr, borderColor: '#ff7b72', borderWidth: 3, pointRadius: 0 },
            { label: 'Act Roll (deg)',  data: angData.ar, borderColor: '#bd561d', borderWidth: 3, pointRadius: 0 },
          ]
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          spanGaps: true,
          scales: {
            x: { type: 'linear', display: true, min: 0, max: WINDOW_SEC, title: { text: 'Time (s)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
            y: { position: 'left', title: { text: 'Angle (deg)', display: true, color: '#9fb1c9' }, ticks: { color: '#9fb1c9' }, grid: { color: '#222' } },
          },
          plugins: { legend: { labels: { color: '#c9d1d9' } } }
        }
      });

      function addPoint(t, spx, x, spy, y) {
        dataX.sp.push({ x: t, y: spx });
        dataX.y.push({ x: t, y: x });
        dataY.sp.push({ x: t, y: spy });
        dataY.y.push({ x: t, y: y });
      }

      function addAnglePoints(t, cpDeg, apDeg, crDeg, arDeg) {
        angData.cp.push({ x: t, y: cpDeg });
        angData.ap.push({ x: t, y: apDeg });
        angData.cr.push({ x: t, y: crDeg });
        angData.ar.push({ x: t, y: arDeg });
      }

      let t0 = null;
      let lastDraw = 0;
      let samples = 0;
      let lastRateT = 0;
      let measuredRate = 0;
      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'state') {
          const s = msg.data || {};
          methodSel.value = s.control_method || 'pid';
          spxEl.value = s.setpoint_x ?? 0;
          spyEl.value = s.setpoint_y ?? 0;
          if (typeof s.imu_feedback_gain === 'number') imuGainEl.value = s.imu_feedback_gain;
          if (s.pid) {
            pp_kp.value = s.pid.pitch.kp; pp_ki.value = s.pid.pitch.ki; pp_kd.value = s.pid.pitch.kd;
            pr_kp.value = s.pid.roll.kp; pr_ki.value = s.pid.roll.ki; pr_kd.value = s.pid.roll.kd;
          }
        } else if (msg.type === 'telemetry') {
          const d = msg.data || {};
          if (t0 == null) t0 = d.t;
          const t = d.t - t0;
          addPoint(t, d.setpoint_x, d.ball_x, d.setpoint_y, d.ball_y);
          samples++;
          if (!lastRateT) lastRateT = d.t; else if (d.t - lastRateT >= 1.0) { measuredRate = samples / (d.t - lastRateT); samples = 0; lastRateT = d.t; }

          // Commanded vs actual angles (deg): prefer IMU when connected
          const cmdPitchDeg = ((d.action?.[0] ?? 0) * 180 / Math.PI);
          const cmdRollDeg  = ((d.action?.[1] ?? 0) * 180 / Math.PI);
          const imuConnected = !!(d.imu && d.imu.connected);
          const actPitchDeg = imuConnected ? (d.imu.pitch ?? 0) : ((d.pitch ?? 0) * 180 / Math.PI);
          const actRollDeg  = imuConnected ? (d.imu.roll ?? 0)  : ((d.roll  ?? 0) * 180 / Math.PI);
          addAnglePoints(t, cmdPitchDeg, actPitchDeg, cmdRollDeg, actRollDeg);

          statusEl.textContent = `render ~${(1000/Math.max(1, performance.now()-lastDraw)).toFixed(0)} fps | recv ${measuredRate.toFixed(0)} Hz`;
        }
      };

      // Smooth render loop decoupled from WS rate (~30 fps)
      function renderLoop(ts) {
        if (!lastDraw || ts - lastDraw > 33) { // ~30Hz
          const all = [dataX.sp, dataX.y, dataY.sp, dataY.y];
          // Trim to moving window
          let tMax = 0;
          for (const arr of all) if (arr.length) tMax = Math.max(tMax, arr[arr.length - 1].x);
          const tMin = Math.max(0, tMax - WINDOW_SEC);
          for (const arr of all) {
            while (arr.length && arr[0].x < tMin) arr.shift();
          }
          chart.options.scales.x.min = tMin;
          chart.options.scales.x.max = tMin + WINDOW_SEC;
          chart.update('none');
          // Trim second chart
          const all2 = [angData.cp, angData.ap, angData.cr, angData.ar];
          let tMax2 = 0;
          for (const arr of all2) if (arr.length) tMax2 = Math.max(tMax2, arr[arr.length - 1].x);
          const tMin2 = Math.max(0, tMax2 - WINDOW_SEC);
          for (const arr of all2) {
            while (arr.length && arr[0].x < tMin2) arr.shift();
          }
          angleChart.options.scales.x.min = tMin2;
          angleChart.options.scales.x.max = tMin2 + WINDOW_SEC;
          angleChart.update('none');
          lastDraw = ts;
        }
        requestAnimationFrame(renderLoop);
      }
      requestAnimationFrame(renderLoop);

      document.getElementById('apply_pid').onclick = () => {
        ws.send(JSON.stringify({ type: 'update_pid', data: { axis: 'pitch', kp: +pp_kp.value, ki: +pp_ki.value, kd: +pp_kd.value } }));
        ws.send(JSON.stringify({ type: 'update_pid', data: { axis: 'roll',  kp: +pr_kp.value, ki: +pr_ki.value, kd: +pr_kd.value } }));
      };
      document.getElementById('apply_sp').onclick = () => {
        ws.send(JSON.stringify({ type: 'set_setpoint', data: { x: +spxEl.value, y: +spyEl.value } }));
      };
      document.getElementById('apply_circle').onclick = () => {
        ws.send(JSON.stringify({ type: 'circle', data: { on: circleOn.value === 'on', radius: +radiusEl.value, speed: +speedEl.value, invert: invertEl.value === 'true' } }));
      };
      methodSel.onchange = () => {
        ws.send(JSON.stringify({ type: 'set_method', data: { method: methodSel.value } }));
      };
      imuGainEl.onchange = () => {
        const val = Math.max(0, Math.min(1, +imuGainEl.value || 0));
        imuGainEl.value = val;
        ws.send(JSON.stringify({ type: 'set_imu_gain', data: { gain: val } }));
      };
    </script>
  </body>
  </html>

